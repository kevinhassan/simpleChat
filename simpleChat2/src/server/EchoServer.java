package server;// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import java.io.*;import common.ChatIF;import ocsf.server.*;/** * This class overrides some of the methods in the abstract  * superclass in order to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer extends AbstractServer {    private ChatIF serverUI;//Constructors ****************************************************    /**   * Constructs an instance of the echo server.   *   * @param port The port number to connect on.   */  public EchoServer(int port, ChatIF serverUI)   {    super(port);    this.serverUI = serverUI;  }  protected void clientConnected(ConnectionToClient client) {	  serverUI.display("The client is connected ");  }  protected void clientDisconnected(ConnectionToClient client) {	  serverUI.display("The client is disconnected ");  }  protected void clientException(ConnectionToClient client, Throwable exception) {	  serverUI.display("The client is brutally disconnected ");  }  //Instance methods ************************************************    /**   * This method handles any messages received from the client.   *   * @param msg The message received from the client.   * @param client The connection from which the message originated.   */  public void handleMessageFromClient(Object msg, ConnectionToClient client) {    String[] message = msg.toString().split(" ");    if(message[0].equals("#quit") || message[0].equals("#logoff")){	    	try {			client.close();			serverUI.display("The client : "+client.getInfo("id")+ "has been disconnected.");		} catch (IOException e) {			e.printStackTrace();		}    }else if(message[0].equals("#login")){    	client.setInfo("id", message[1]);    	serverUI.display("A new client is connected as : "+ client.getInfo("id"));    }    else{    	this.sendToAllClients(msg);    	serverUI.display("Message received: " + msg + " from " + client.getInfo("id"));    }  }    public void handleMessageFromServerUI(Object msg) {	  String[] message = msg.toString().split(" ");	  switch(message[0]){		case "#quit":			System.exit(0);			break;		case "#stop":			stopListening();			break;		case "#close":		try {			stopListening();			close();		} catch (IOException e) {			e.printStackTrace();		}			break;		case "#setport":			if (!isListening()){				String port = message[1];				setPort(Integer.parseInt(port));			}			break;		case "#start":			if (!isListening()){				try {					listen();				} catch (IOException e) {					e.printStackTrace();				}			}			break;		case "#getport":			serverUI.display(Integer.toString(getPort()));			break;		default:			this.sendToAllClients("Server MSG> "+msg);		}  }      /**   * This method overrides the one in the superclass.  Called   * when the server starts listening for connections.   */  protected void serverStarted()  {	  serverUI.display("Server listening for connections on port " + getPort());  }    /**   * This method overrides the one in the superclass.  Called   * when the server stops listening for connections.   */  protected void serverStopped()  {	  serverUI.display("Server has stopped listening for connections.");  }    public void accept()   {    try    {      BufferedReader fromConsole =         new BufferedReader(new InputStreamReader(System.in));      String message;            while (true)       {        message = fromConsole.readLine();        handleMessageFromServerUI(message);      }    }     catch (Exception ex)     {      serverUI.display        ("Unexpected error while reading from console!");    }  }}//End of EchoServer class