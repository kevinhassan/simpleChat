package server;// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import java.io.*;import java.util.Observable;import java.util.Observer;import com.lloseng.ocsf.server.*;import common.ChatIF;/** * This class overrides some of the methods in the abstract  * superclass in order to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer implements Observer {  	/**     * The interface type variable.  It allows the implementation of      * the display method in the client.	 */	private ChatIF serverUI;		/**	 * The class type variable. It allows the implementation of     * all the communication method in the server.	 */	private ObservableOriginatorServer oServer;	//Constructors ****************************************************	/**	 * Constructs an instance of the echo server.	 *	 * @param port The port number to connect on.	 * @param serverUI The server interface to communicate with.	 */	public EchoServer(int port, ChatIF serverUI) 	{		this.serverUI = serverUI;		oServer = new ObservableOriginatorServer(port);		oServer.addObserver(this);	}	/**	 * @Override	 * @param client	 */	protected void clientConnected(ConnectionToClient client) {		serverUI.display("The client is connected ");	}	/**	 * @Override	 * @param client	 */	protected void clientDisconnected(ConnectionToClient client) {		serverUI.display("The client is disconnected ");	}	/**	 * Override	 * @param client	 * @param exception	 */	protected void clientException(ConnectionToClient client, Throwable exception) {		serverUI.display("The client is brutally disconnected ");	}	//Instance methods ************************************************	/**	 * This method handles any messages received from the client.	 *	 * @param msg The message received from the client.	 * @param client The connection from which the message originated.	 */	public void handleMessageFromClient(Object msg, ConnectionToClient client) {		String[] message = msg.toString().split(" ");		if(message[0].equals("#quit") || message[0].equals("#logoff")){				try {				client.close();				serverUI.display("The client : "+client.getInfo("id")+ " has been disconnected.");			} catch (IOException e) {				e.printStackTrace();			}		}else if(message[0].equals("#login")){			client.setInfo("id", message[1]);			serverUI.display("A new client is connected as : "+ client.getInfo("id"));		}		else{			oServer.sendToAllClients(client.getInfo("id")+" > " +msg);			serverUI.display("Message received: " + msg + " from " + client.getInfo("id"));		}	}	/**	 * This method handles any messages received from the server.	 * @param msg The message received from the server.	 */	public void handleMessageFromServerUI(Object msg) {		String[] message = msg.toString().split(" ");		switch(message[0]){		case "#quit":			System.exit(0);			break;		case "#stop":			oServer.stopListening();			break;		case "#close":			try {				if (oServer.isListening()){					oServer.stopListening();					oServer.close();				}			} catch (IOException e) {				e.printStackTrace();			}			break;		case "#setport":			if (!oServer.isListening()){				String port = message[1];				oServer.setPort(Integer.parseInt(port));			}			break;		case "#start":			if (!oServer.isListening()){				try {					oServer.listen();				} catch (IOException e) {					e.printStackTrace();				}			}			break;		case "#getport":			serverUI.display(Integer.toString(oServer.getPort()));			break;		default:			oServer.sendToAllClients("Server MSG> "+msg);		}	}	/**	 * This method overrides the one in the superclass.  Called	 * when the server starts listening for connections.	 */	protected void serverStarted()	{		serverUI.display("Server listening for connections on port " + oServer.getPort());	}	/**	 * This method overrides the one in the superclass.  Called	 * when the server stops listening for connections.	 */	protected void serverStopped()	{		serverUI.display("Server has stopped listening for connections.");	}	/**	 * This method overrides the one in the superclass.  Called	 * when the server stops listening for connections.	 */	protected void serverClosed()	{		serverUI.display("Server has been closed nicely.");	}	/**	 * This method waits for input from the console. Once it is 	 * received, it sends it to the server's message handler.	 */	public void accept() 	{		try		{			BufferedReader fromConsole = 					new BufferedReader(new InputStreamReader(System.in));			String message;			while (true) 			{				message = fromConsole.readLine();				handleMessageFromServerUI(message);			}		} 		catch (Exception ex) 		{			serverUI.display			("Unexpected error while reading from console!");		}	}	@Override	public void update(Observable o, Object arg) {		if (arg instanceof OriginatorMessage) {			String msg = (((OriginatorMessage) arg).getMessage().toString());			if(((OriginatorMessage) arg).getOriginator() instanceof ConnectionToClient){				switch(msg){				case ObservableServer.CLIENT_CONNECTED:					clientConnected(((OriginatorMessage) arg).getOriginator());					break;				case ObservableServer.CLIENT_DISCONNECTED:					clientDisconnected(((OriginatorMessage) arg).getOriginator());					break;				case ObservableServer.CLIENT_EXCEPTION:					clientException(((OriginatorMessage) arg).getOriginator(),new Throwable(ObservableServer.CLIENT_EXCEPTION));				default:					handleMessageFromClient(msg,((OriginatorMessage) arg).getOriginator());					break;				}//END SWITCH			}else {				switch(msg){				case ObservableServer.SERVER_STARTED:					serverStarted();					break;				case ObservableServer.SERVER_STOPPED:					serverStopped();					break;				case ObservableServer.SERVER_CLOSED:					serverClosed();					break;				case ObservableServer.LISTENING_EXCEPTION:					listeningException(new Throwable(msg.split(ObservableServer.LISTENING_EXCEPTION)[1]));					break;				}//END SWITCH			}//END ELSE		}	}	/**	 * @Override	 * @param throwable	 */	private void listeningException(Throwable throwable) {		serverUI.display("The server stopped to listen brutally.");	}}//End of EchoServer class